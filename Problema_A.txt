;
; AssemblerApplication31.asm
;
; Created: 9/20/2025 3:34:02 PM
; Author : isacm
;

; Macros para brne y breq
.macro BREQ_RJMP 
    BRNE end
    rjmp @0
	end:
	.endmacro

.macro BRNE_RJMP 
    breq end
    rjmp @0
	end:
	.endmacro

 .include "m328pdef.inc"

; Constantes a utilizar

	; Para USART
	.equ TX_BUF_SIZE = 256				; power of two
	.equ TX_BUF_MASK = TX_BUF_SIZE - 1		; 0x0F for size 1
	.equ _F_CPU = 16000000
	.equ _BAUD = 9600
	.equ _BPS = (_F_CPU/16/_BAUD) - 1
	
	; Tipos de carga
	.equ CARGA_LIVIANA = 6
	.equ CARGA_MEDIA = 7
	.equ CARGA_PESADA = 8

	; Estados
	.equ S_ESPERA        = 0  ; 1. En espera – Sistema listo, esperando inicio
	.equ S_CINTA		 = 1   ; 2. Cinta – La cinta transporta la pieza
	.equ S_POSICIONADO   = 2
	.equ S_PUNZONADO     = 3   ; 3. Punzonado – Activación del punzón
	.equ S_CINTA_INVERSA = 4 ; 3. Punzonado – Subirlo cuando termine el timer
	.equ S_ESPERA2        = 5  ; 1. En espera – Sistema listo, esperando inicio

	; Salidas 
	.equ MOVER_CINTA = (0<<PD6) | (0<<PD5) | (1<<PD3)
	.equ MOVER_PUNZONADORA = (1<<PD6) | (0<<PD5) | (0<<PD3)
	.equ APAGAR_PUNZONADORA = (0<<PD6) | (0<<PD5) | (0<<PD3)
	.equ MOVER_CINTA_INVERSA = (0<<PD6) | (1<<PD5) | (0<<PD3)

	; Registros a utilizar
	.def TIPO_Carga= r19
	.def ESTADO= r20
	.def EVENTO= r21

; Constantes para evaluar el cambio de estado
	;Liviano
	.equ A = 1
	.equ B = 4
	.equ C = 6
	.equ D = 9
	.equ E = 12

	;Media
	.equ A2 = 1
	.equ B2 = 5
	.equ C2 = 7
	.equ D2 = 10
	.equ E2 = 13

	; Pesada
	.equ A3 = 1
	.equ B3 = 6
	.equ C3 = 10
	.equ D3 = 14
	.equ E3 = 17


; Inicializacion de interrupciones
	.org 0x001A
		rjmp CAMBIAR_ESTADO

	.org 0x0024 
		rjmp USART_RX_ISR	; Recieved USART data



	.org 0x200
		rjmp INICIO



INICIO:
`	ldi r16, high(RAMEND) ; Inicializamos en STACK
	out SPH, r16
	ldi r16, low(RAMEND)
	out SPL, r16 
	
	 ; ---------- TIMER1 ----------
    ; Modo normal
    ldi r16, 0x00
    sts TCCR1A, r16
    ; Prescaler = /1024 -> CS12=1, CS11=0, CS10=1 (0b101 = 0x05)
    ldi r16, 0x05
    sts TCCR1B, r16

	; Habilitar interrupción por desbordamiento de Timer1
    LDI r16, (1<<TOIE1)
    STS TIMSK1, r16

	; ---------- Configuramos USART ---------- 

	ldi r16, low(_BPS)
	ldi r17, high(_BPS)
	; Set baud rate
	sts UBRR0H, r17
	sts UBRR0L, r16
	; Configurar la recepcion, transmicion e interrupcion de USART
	ldi r16, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
	sts UCSR0B,r16
	; COnfigurar los datos de transmicion y de parada; 8data, 2stop bit
	ldi r16, (1<<USBS0)|(3<<UCSZ00)
	sts UCSR0C,r16


	sei

	; --- PORTD setup ---
	; Salidas: PD6, PD5, PD4 (READY), PD3
	; Entrada: PD2 (START) con pull-up
	ldi  r16, (1<<PD6)|(1<<PD5)|(1<<PD4)|(1<<PD3)
	out  DDRD, r16

	; Pull-up en START
	sbi  PORTD, PD2

	; READY = 1 (listo al inicio)
	sbi  PORTD, PD4

	ldi EVENTO, 0
	
	ldi ESTADO, S_ESPERA
	ldi TIPO_Carga, CARGA_PESADA 
	

    rjmp main


; La inicialización donde configuramos, los pines que se van a comportar como salida y entrada en el cidgo, y el timer





main:     
	;Switch para saber que hacer

	cpi  ESTADO, S_ESPERA
    BREQ_RJMP ST_ESPERA

    cpi  ESTADO, S_CINTA
    BREQ_RJMP ST_CINTA

	cpi  ESTADO, S_POSICIONADO 
    BREQ_RJMP ST_POSICIONADO

	cpi  ESTADO, S_PUNZONADO 
    BREQ_RJMP ST_PUNZONADORA

	cpi ESTADO, S_CINTA_INVERSA 
	BREQ_RJMP ST_CINTA_INVERSA 

	cpi  ESTADO, S_ESPERA2
    BREQ_RJMP ST_ESPERAA2
	
    rjmp main

; En el main se evalúa el evento, y según que evento este activa las salidas


ST_ESPERA:
    ; Mantener salidas apagadas
    ldi  r16, APAGAR_PUNZONADORA
    out  PORTD, r16

    ; READY = 1 mientras esperamos
    sbi  PORTD, PD4

    ; ¿START presionado? (PD2 con pull-up: 0 = presionado)
    sbic PIND, PD2          ; salta si PD2==0 (presionado)
    rjmp no_start

    ; Inicio: bajamos READY y arrancamos ciclo
    cbi  PORTD, PD4         ; READY = 0
    clr  EVENTO
    ldi  ESTADO, S_CINTA
    rjmp main

no_start:
    rjmp main

ST_CINTA:
    ldi  r16, MOVER_CINTA
    out  PORTD, r16
    cbi  PORTD, PD4         ; READY = 0 (en proceso)
    rjmp main

ST_PUNZONADORA:
    ldi  r16, MOVER_PUNZONADORA
    out  PORTD, r16
    cbi  PORTD, PD4
    rjmp main

ST_CINTA_INVERSA:
    ldi  r16, MOVER_CINTA_INVERSA
    out  PORTD, r16
    cbi  PORTD, PD4
    rjmp main

ST_POSICIONADO:
    ldi  r16, APAGAR_PUNZONADORA
    out  PORTD, r16
    cbi  PORTD, PD4
    rjmp main

ST_ESPERAA2:
    ldi  r16, APAGAR_PUNZONADORA
    out  PORTD, r16
    cbi  PORTD, PD4
    rjmp main


CAMBIAR_ESTADO:
	push r17
    in r17, SREG 
	push r17
	rcall delay
	
	inc EVENTO
	
    cpi  ESTADO, S_ESPERA
    BREQ_RJMP ST_ESPERA1

	cpi  ESTADO, S_CINTA
    BREQ_RJMP ST_CINTA1

	cpi ESTADO, S_POSICIONADO
	BREQ_RJMP ST_POSICIONADO1

	cpi  ESTADO, S_PUNZONADO
    BREQ_RJMP ST_PUNZONADORA1

	cpi  ESTADO, S_CINTA_INVERSA
    BREQ_RJMP ST_CINTA_INVERSA1

    cpi  ESTADO, S_ESPERA2
    BREQ_RJMP ST_ESPERA2_1

    rjmp volv                   ; default si no coincide
; -------------------- ESTADO: ESPERA (0) --------------------
ST_ESPERA1:
    ; switch (TIPO_Carga)
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_ESPERA1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_ESPERA1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_ESPERA1_P
    rjmp volv

ST_ESPERA1_L:             ; liviana
    cpi  EVENTO, A
    BRNE_RJMP volv
    ldi  ESTADO, S_CINTA          ; <-- cambialo si querés
    rjmp volv

ST_ESPERA1_M:             ; media
    cpi  EVENTO, A2
    BRNE_RJMP volv
    ldi  ESTADO, S_CINTA          ; (ej.: podrías pedir 2 ticks: cpi EVENTO, A+1)
    rjmp volv

ST_ESPERA1_P:             ; pesada
    cpi  EVENTO, A3
    BRNE_RJMP volv
    ldi  ESTADO, S_CINTA
    rjmp volv

ST_ESPERA1_DEF:           ; default
    cpi  EVENTO, A
    BRNE_RJMP volv
    ldi  ESTADO, S_CINTA
    rjmp volv


; -------------------- ESTADO: CINTA (1) --------------------
ST_CINTA1:
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_CINTA1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_CINTA1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_CINTA1_P
	rjmp volv
   
ST_CINTA1_L:
    cpi  EVENTO, B
    BRNE_RJMP volv
    ldi  ESTADO, S_POSICIONADO    ; liviana → posiciona rápido
    rjmp volv

ST_CINTA1_M:
    cpi  EVENTO, B2
    BRNE_RJMP volv
    ldi  ESTADO, S_POSICIONADO    ; media (podés requerir B+1 si querés más tiempo de cinta)
    rjmp volv

ST_CINTA1_P:
    ; ejemplo: pesada necesita más “tiempo de cinta”
    cpi  EVENTO, B3
    BRNE_RJMP volv
    ldi  ESTADO, S_POSICIONADO
    rjmp volv

ST_CINTA1_DEF:
    cpi  EVENTO, B
    BRNE_RJMP volv
    ldi  ESTADO, S_POSICIONADO
    rjmp volv


; -------------------- ESTADO: POSICIONADO (2) ----------------
ST_POSICIONADO1:
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_POS1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_POS1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_POS1_P
	rjmp volv
    
ST_POS1_L:
    cpi  EVENTO, C
    BRNE_RJMP volv
    ldi  ESTADO, S_PUNZONADO      ; liviana: punzona antes
    rjmp volv

ST_POS1_M:
    cpi  EVENTO, C2
    BRNE_RJMP volv
    ldi  ESTADO, S_PUNZONADO
    rjmp volv

ST_POS1_P:
    ; pesada: podrías exigir un tick más de posicionamiento
    cpi  EVENTO, C3
    BRNE_RJMP volv
    ldi  ESTADO, S_PUNZONADO
    rjmp volv



; -------------------- ESTADO: PUNZONADO (3) ----------------
ST_PUNZONADORA1:
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_PUNZ1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_PUNZ1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_PUNZ1_P
    rjmp volv

ST_PUNZ1_L:
    cpi  EVENTO, D
    BRNE_RJMP volv
    ldi  ESTADO, S_CINTA_INVERSA
    rjmp volv

ST_PUNZ1_M:
    cpi  EVENTO, D2
    BRNE_RJMP volv
    ldi  ESTADO, S_CINTA_INVERSA
    rjmp volv

ST_PUNZ1_P:
    ; pesada: punzonado podría durar más (usa otro umbral si querés)
    cpi  EVENTO, D3
    BRNE_RJMP volv
    ldi  ESTADO, S_CINTA_INVERSA
    rjmp volv



; -------------------- ESTADO: CINTA_INVERSA (4) ------------
ST_CINTA_INVERSA1:
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_CINVI1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_CINVI1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_CINVI1_P
    rjmp volv

ST_CINVI1_L:
    cpi  EVENTO, E
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA2
    rjmp volv

ST_CINVI1_M:
    cpi  EVENTO, E2
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA2
    rjmp volv

ST_CINVI1_P:
    ; pesada: quizá precisa retroceder más tiempo
    cpi  EVENTO, E3
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA2
    rjmp volv



; -------------------- ESTADO: ESPERA2 (5) ------------------
ST_ESPERA2_1:
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_ESPERA2_1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_ESPERA2_1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_ESPERA2_1_P
    rjmp volv

ST_ESPERA2_1_L:
    cpi  EVENTO, A
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA
    sbi  PORTD, PD4         ; READY = 1 (ciclo terminado)
    rjmp  volv

; Igual en _M y _P:
ST_ESPERA2_1_M:
    cpi  EVENTO, A2
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA
    sbi  PORTD, PD4
    rjmp  volv

ST_ESPERA2_1_P:
    cpi  EVENTO, A3
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA
    sbi  PORTD, PD4
    rjmp  volv

volv:
	pop r17
	out SREG, r17
	pop r17
    reti



; === ISR de recepción USART: recibe '0'..'4' y los mapea a estados 0..4 ===
USART_RX_ISR:
    push r16
    in   r16, SREG
    push r16

    lds  r16, UDR0              ; leer dato recibido limpia RXC

    ; Si llega ASCII '0'..'4', convertir a 0..4 y cargar ESTADO
    cpi  r16, '0'
    brlo usart_end              ; < '0' ? ignorar
    cpi  r16, '3'+1
    brsh usart_end              ; > '3' ? ignorar
    subi r16, '0'               
    mov  TIPO_Carga, r16
    clr  EVENTO                 ; opcional: reiniciar evento al cambiar carga por comando

usart_end:
    pop  r16
    out  SREG, r16
    pop  r16
    reti

delay:
	push r16
	in r16, sreg
	push r16

    ldi  r16, high(0xC2F7)
    sts  TCNT1H, r16
    ldi  r16, low(0xC2F7)
    sts  TCNT1L, r16

	pop r16
	out sreg, r16
	pop r16
    ret
/*
USART_WRITE_BYTE:
    push r17
    push r18
    push r19
    push ZH
    push ZL

    ; head/tail
    lds  r17, tx_head
    lds  r18, tx_tail

    ; next = (head + 1) & MASK   (keep it in r19!)
    mov  r19, r17
    inc  r19
    andi r19, TX_BUF_MASK

wait_space:
    ; full? next == tail
    cp   r19, r18
    brne have_space
    ; maybe ISR advanced tail while we were here ? reload tail and re-check
    lds  r18, tx_tail
    cp   r19, r18
    breq wait_space

have_space:
    ; Z = &tx_buffer[head]
    ldi  ZL, low(tx_buffer)
    ldi  ZH, high(tx_buffer)
    add  ZL, r17
    adc  ZH, r1            ; r1 must be 0

    st   Z, r16            ; write byte

    ; head = next   (use r19, NOT ZL)
    sts  tx_head, r19

    ; enable UDRE interrupt so ISR starts/continues draining
    cli
    lds  r18, UCSR0B
    ori  r18, (1<<UDRIE0)
    sts  UCSR0B, r18
    sei

    pop  ZL
    pop  ZH
    pop  r19
    pop  r18
    pop  r17
    ret

; Preload Z with the message
SEND_MESSAGE:
	push r16

	SEND_MESSAGE_LOOP:
	lpm r16, Z+
	cpi r16, 0

	breq SEND_MESSAGE_END
	rcall USART_WRITE_BYTE
	rjmp SEND_MESSAGE_LOOP

	SEND_MESSAGE_END:
	pop r16
	ret*/






