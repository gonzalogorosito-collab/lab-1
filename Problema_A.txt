;
; AssemblerApplication31.asm
;
; Created: 9/20/2025 3:34:02 PM
; Author : isacm
;

; Macros para brne y breq
.macro BREQ_RJMP 
    BRNE end
    rjmp @0
	end:
	.endmacro

.macro BRNE_RJMP 
    breq end
    rjmp @0
	end:
	.endmacro

 .include "m328pdef.inc"

; Constantes a utilizar

	; Para USART
	.equ TX_BUF_SIZE = 256				; power of two
	.equ TX_BUF_MASK = TX_BUF_SIZE - 1		; 0x0F for size 1
	.equ _F_CPU = 16000000
	.equ _BAUD = 9600
	.equ _BPS = (_F_CPU/16/_BAUD) - 1
	
	; Tipos de carga
	.equ CARGA_LIVIANA = 1
	.equ CARGA_MEDIA = 2
	.equ CARGA_PESADA = 3

	; Estados
	.equ S_ESPERA        = 0  ; 1. En espera – Sistema listo, esperando inicio
	.equ S_CINTA		 = 1   ; 2. Cinta – La cinta transporta la pieza
	.equ S_POSICIONADO   = 2
	.equ S_PUNZONADO     = 3   ; 3. Punzonado – Activación del punzón
	.equ S_CINTA_INVERSA = 4 ; 3. Punzonado – Subirlo cuando termine el timer
	.equ S_ESPERA2        = 5  ; 1. En espera – Sistema listo, esperando inicio

	; Salidas 
	.equ MOVER_CINTA = (0<<PD6) | (0<<PD5) | (1<<PD3)
	.equ MOVER_PUNZONADORA = (1<<PD6) | (0<<PD5) | (0<<PD3)
	.equ APAGAR_PUNZONADORA = (0<<PD6) | (0<<PD5) | (0<<PD3)
	.equ MOVER_CINTA_INVERSA = (0<<PD6) | (1<<PD5) | (0<<PD3)

	
	; Registros a utilizar
	.def TIPO_Carga= r19
	.def ESTADO= r20
	.def EVENTO= r21
	.def CONTADOR= r22

; Constantes para evaluar el cambio de estado
	;Liviano
	.equ A = 1
	.equ B = 4
	.equ C = 6
	.equ D = 9
	.equ E = 12

	;Media
	.equ A2 = 1
	.equ B2 = 5
	.equ C2 = 7
	.equ D2 = 10
	.equ E2 = 13

	; Pesada
	.equ A3 = 1
	.equ B3 = 6
	.equ C3 = 10
	.equ D3 = 14
	.equ E3 = 17

	; Espacio para las vairables guardadas en la RAM
	.dseg ; data segment
		tx_buffer: .byte TX_BUF_SIZE          ; circular buffer storage
		tx_head:   .byte 1                    ; enqueue index
		tx_tail:   .byte 1                    ; dequeue index


	.cseg
	.org 0x0000
		rjmp INICIO 
; Inicializacion de interrupciones
	.org 0x001A
		rjmp CAMBIAR_ESTADO
	.org 0x0024 
		rjmp USART_RX_ISR	; Recieved USART data
	.org 0x0026 
		rjmp USART_UDRE_ISR ; USART Data register clear
	.org  0x000A
		rjmp Interrupcion_PCINT;PC 5


.org 0x100
INICIO:
`	ldi r16, high(RAMEND) ; Inicializamos en STACK
	out SPH, r16
	ldi r16, low(RAMEND)
	out SPL, r16 
	
	 ; ---------- TIMER1 ----------
    ; Modo normal
    ldi r16, 0x00
    sts TCCR1A, r16
    ; Prescaler = /1024 -> CS12=1, CS11=0, CS10=1 (0b101 = 0x05)
    ldi r16, 0x05
    sts TCCR1B, r16

	; Habilitar interrupción por desbordamiento de Timer1
    LDI r16, (1<<TOIE1)
    STS TIMSK1, r16

	; ---------- Configuramos USART ---------- 

	ldi r16, low(_BPS)
	ldi r17, high(_BPS)
	; Set baud rate
	sts UBRR0H, r17
	sts UBRR0L, r16
	; Configurar la recepcion, transmicion e interrupcion de USART
	ldi r16, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
	sts UCSR0B,r16
	; COnfigurar los datos de transmicion y de parada; 8data, 2stop bit
	ldi r16, (1<<USBS0)|(3<<UCSZ00)
	sts UCSR0C,r16


	

	; --- PORTD setup ---
	; Salidas: PD6, PD5, PD4 (READY), PD3
	; Entrada: PD2 (START) con pull-up
	ldi  r16, (1<<PD6)|(1<<PD5)|(1<<PD3)
	out  DDRD, r16

	ldi r16, 0xff
	out DDRC, r16
	sbi PORTC, PC0

	ldi  r16, 0
	sts  tx_head, r16
	sts  tx_tail, r16
	clr  r1 
	sts Comenzar, r16

	ldi EVENTO, 0
	
	ldi ESTADO, S_ESPERA
	ldi TIPO_Carga, CARGA_PESADA 
	sbi PORTC, PC4

	ldi  ZL, low(MSG_MENU<<1)
    ldi  ZH, high(MSG_MENU<<1)



    ; PD2..PD7 = PCINT18..23 -> bits2..7 de PCMSK2
    ldi  r16, (1<<2) | (1<<7)
    sts  PCMSK2, r16

	sbi PORTD, PD2
	sbi PORTD, PD7
	

    ; Habilitar grupos PCINT1 (PORTC) y PCINT2 (PORTD)
    ldi  r16, (1<<PCIE2)
    sts  PCICR, r16

    ; Limpiar flags pendientes
    ldi  r16,  (1<<PCIF2)
    sts  PCIFR, r16

    rcall SEND_MESSAGE
	sei
    rjmp main


; La inicialización donde configuramos, los pines que se van a comportar como salida y entrada en el cidgo, y el timer





main:     
	;Switch para saber que hacer
	

	cpi  ESTADO, S_ESPERA
    BREQ_RJMP ST_ESPERA

    cpi  ESTADO, S_CINTA
    BREQ_RJMP ST_CINTA

	cpi  ESTADO, S_POSICIONADO 
    BREQ_RJMP ST_POSICIONADO

	cpi  ESTADO, S_PUNZONADO 
    BREQ_RJMP ST_PUNZONADORA

	cpi ESTADO, S_CINTA_INVERSA 
	BREQ_RJMP ST_CINTA_INVERSA 

	cpi  ESTADO, S_ESPERA2
    BREQ_RJMP ST_ESPERAA2
	
    rjmp main

; En el main se evalúa el evento, y según que evento este activa las salidas




USART_WRITE_BYTE:
    push r17
    push r18
    push r19
    push ZH
    push ZL

    ; head/tail
    lds  r17, tx_head
    lds  r18, tx_tail

    ; next = (head + 1) & MASK   (keep it in r19!)
    mov  r19, r17
    inc  r19
    andi r19, TX_BUF_MASK

wait_space:
    ; full? next == tail
    cp   r19, r18
    brne have_space
    ; maybe ISR advanced tail while we were here ? reload tail and re-check
    lds  r18, tx_tail
    cp   r19, r18
    breq wait_space

have_space:
    ; Z = &tx_buffer[head]
    ldi  ZL, low(tx_buffer)
    ldi  ZH, high(tx_buffer)
    add  ZL, r17
    adc  ZH, r1            ; r1 must be 0

    st   Z, r16            ; write byte

    ; head = next   (use r19, NOT ZL)
    sts  tx_head, r19

    ; enable UDRE interrupt so ISR starts/continues draining
    cli
    lds  r18, UCSR0B
    ori  r18, (1<<UDRIE0)
    sts  UCSR0B, r18
    sei

    pop  ZL
    pop  ZH
    pop  r19
    pop  r18
    pop  r17
    ret

ST_ESPERA:
	sbi PORTC, PC0
	cbi PORTC, PC1
    ldi  r16, APAGAR_PUNZONADORA
    out  PORTD, r16
    ;ldi  ESTADO, S_ESPERA
    rjmp main


ST_CINTA:
	sbi PORTC, PC1
	cbi PORTC, PC0
    ldi  r16, MOVER_CINTA
    out  PORTD, r16
    rjmp main

ST_PUNZONADORA:
    ldi  r16, MOVER_PUNZONADORA
    out  PORTD, r16
    rjmp main

ST_CINTA_INVERSA:
    ldi  r16, MOVER_CINTA_INVERSA
    out  PORTD, r16
    rjmp main

ST_POSICIONADO:
    ldi  r16, APAGAR_PUNZONADORA
    out  PORTD, r16
    rjmp main

ST_ESPERAA2:
	cbi PORTC, PC1
	sbi PORTC, PC0
    ldi  r16, APAGAR_PUNZONADORA
    out  PORTD, r16
    rjmp main


CAMBIAR_ESTADO:
	push r17
    in r17, SREG 
	push r17
	rcall delay
	
	inc EVENTO
	
    cpi  ESTADO, S_ESPERA
    BREQ_RJMP ST_ESPERA1

	cpi  ESTADO, S_CINTA
    BREQ_RJMP ST_CINTA1

	cpi ESTADO, S_POSICIONADO
	BREQ_RJMP ST_POSICIONADO1

	cpi  ESTADO, S_PUNZONADO
    BREQ_RJMP ST_PUNZONADORA1

	cpi  ESTADO, S_CINTA_INVERSA
    BREQ_RJMP ST_CINTA_INVERSA1

    cpi  ESTADO, S_ESPERA2
    BREQ_RJMP ST_ESPERA2_1

    rjmp volv                   ; default si no coincide
; -------------------- ESTADO: ESPERA (0) --------------------
ST_ESPERA1:
    ; switch (TIPO_Carga)
	
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_ESPERA1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_ESPERA1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_ESPERA1_P
    rjmp volv

ST_ESPERA1_L:             ; liviana
    cpi  EVENTO, A
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA          ; <-- cambialo si querés
    rjmp volv

ST_ESPERA1_M:             ; media
    cpi  EVENTO, A2
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA         ; (ej.: podrías pedir 2 ticks: cpi EVENTO, A+1)
    rjmp volv

ST_ESPERA1_P:             ; pesada
    cpi  EVENTO, A3
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA
    rjmp volv


; -------------------- ESTADO: CINTA (1) --------------------
ST_CINTA1:
	sbi PORTC, PC1
	cbi PORTC, PC0
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_CINTA1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_CINTA1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_CINTA1_P
	rjmp volv
   
ST_CINTA1_L:
    cpi  EVENTO, B
    BRNE_RJMP volv
    ldi  ESTADO, S_POSICIONADO    ; liviana → posiciona rápido
    rjmp volv

ST_CINTA1_M:
    cpi  EVENTO, B2
    BRNE_RJMP volv
    ldi  ESTADO, S_POSICIONADO    ; media (podés requerir B+1 si querés más tiempo de cinta)
    rjmp volv

ST_CINTA1_P:
    ; ejemplo: pesada necesita más “tiempo de cinta”
    cpi  EVENTO, B3
    BRNE_RJMP volv
    ldi  ESTADO, S_POSICIONADO
    rjmp volv

ST_CINTA1_DEF:
    cpi  EVENTO, B
    BRNE_RJMP volv
    ldi  ESTADO, S_POSICIONADO
    rjmp volv


; -------------------- ESTADO: POSICIONADO (2) ----------------
ST_POSICIONADO1:
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_POS1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_POS1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_POS1_P
	rjmp volv
    
ST_POS1_L:
    cpi  EVENTO, C
    BRNE_RJMP volv
    ldi  ESTADO, S_PUNZONADO      ; liviana: punzona antes
    rjmp volv

ST_POS1_M:
    cpi  EVENTO, C2
    BRNE_RJMP volv
    ldi  ESTADO, S_PUNZONADO
    rjmp volv

ST_POS1_P:
    ; pesada: podrías exigir un tick más de posicionamiento
    cpi  EVENTO, C3
    BRNE_RJMP volv
    ldi  ESTADO, S_PUNZONADO
    rjmp volv



; -------------------- ESTADO: PUNZONADO (3) ----------------
ST_PUNZONADORA1:
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_PUNZ1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_PUNZ1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_PUNZ1_P
    rjmp volv

ST_PUNZ1_L:
    cpi  EVENTO, D
    BRNE_RJMP volv
    ldi  ESTADO, S_CINTA_INVERSA
    rjmp volv

ST_PUNZ1_M:
    cpi  EVENTO, D2
    BRNE_RJMP volv
    ldi  ESTADO, S_CINTA_INVERSA
    rjmp volv

ST_PUNZ1_P:
    ; pesada: punzonado podría durar más (usa otro umbral si querés)
    cpi  EVENTO, D3
    BRNE_RJMP volv
    ldi  ESTADO, S_CINTA_INVERSA
    rjmp volv



; -------------------- ESTADO: CINTA_INVERSA (4) ------------
ST_CINTA_INVERSA1:
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_CINVI1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_CINVI1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_CINVI1_P
    rjmp volv

ST_CINVI1_L:
    cpi  EVENTO, E
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA2
    rjmp volv

ST_CINVI1_M:
    cpi  EVENTO, E2
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA2
    rjmp volv

ST_CINVI1_P:
    ; pesada: quizá precisa retroceder más tiempo
    cpi  EVENTO, E3
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA2
    rjmp volv



; -------------------- ESTADO: ESPERA2 (5) ------------------
ST_ESPERA2_1:
    cpi  TIPO_Carga, CARGA_LIVIANA
    BREQ_RJMP ST_ESPERA2_1_L
    cpi  TIPO_Carga, CARGA_MEDIA
    BREQ_RJMP ST_ESPERA2_1_M
    cpi  TIPO_Carga, CARGA_PESADA
    BREQ_RJMP ST_ESPERA2_1_P
    rjmp volv

ST_ESPERA2_1_L:
    cpi  EVENTO, A
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA
    rjmp  volv

; Igual en _M y _P:
ST_ESPERA2_1_M:
    cpi  EVENTO, A2
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA
    rjmp  volv

ST_ESPERA2_1_P:
    cpi  EVENTO, A3
    BRNE_RJMP volv
    ldi  ESTADO, S_ESPERA
    rjmp  volv

volv:
	pop r17
	out SREG, r17
	pop r17
    reti



; === ISR de recepción USART: '1','2','3' -> TIPO_Carga ===
USART_RX_ISR:
    push r16
    in   r16, SREG
    push r16

    lds  r16, UDR0                  ; leer dato recibido limpia RXC

    ; switch (r16)
    cpi  r16, '1'
    breq rx_set_liviana
    cpi  r16, '2'
    breq rx_set_media
    cpi  r16, '3'
    breq rx_set_pesada
	cpi r16, 'A'
	breq Iniciar_Estado

    rjmp usart_end                  ; default: ignorar cualquier otra tecla

rx_set_liviana:
	sbi PORTC, PC2
	cbi PORTC, PC3
	cbi PORTC, PC4
    ldi  TIPO_Carga, CARGA_LIVIANA  ; TIPO_Carga = 1
    clr  EVENTO
    rjmp usart_end

rx_set_media:
	sbi PORTC, PC3
	cbi PORTC, PC2
	cbi PORTC, PC4
    ldi  TIPO_Carga, CARGA_MEDIA    ; TIPO_Carga = 2
    clr  EVENTO
    rjmp usart_end

rx_set_pesada:
	sbi PORTC, PC4
	cbi PORTC, PC3
	cbi PORTC, PC2
    ldi  TIPO_Carga, CARGA_PESADA   ; TIPO_Carga = 3
    clr  EVENTO
	rjmp usart_end
    ; fall-through al final
Iniciar_Estado:
	ldi ESTADO, S_CINTA
	clr EVENTO


usart_end:
    pop  r16
    out  SREG, r16
    pop  r16
    reti

delay:
	push r16
	in r16, sreg
	push r16

    ldi  r16, high(0xC2F7)
    sts  TCNT1H, r16
    ldi  r16, low(0xC2F7)
    sts  TCNT1L, r16

	pop r16
	out sreg, r16
	pop r16
    ret


; Preload Z with the message
SEND_MESSAGE:
	push r16

	SEND_MESSAGE_LOOP:
	lpm r16, Z+
	cpi r16, 0

	breq SEND_MESSAGE_END
	rcall USART_WRITE_BYTE
	rjmp SEND_MESSAGE_LOOP

	SEND_MESSAGE_END:
	pop r16
	ret


USART_UDRE_ISR:
    push r16
    in   r16, SREG
    push r16

    push r17
    push r18
    push r20
    push ZH
    push ZL

    ; r17 = head, r18 = tail
    lds  r17, tx_head
    lds  r18, tx_tail

    ; buffer vacío? head == tail
    cp   r17, r18
    brne usart_udre_send

    ; vacío: deshabilitar UDRIE0
    lds  r20, UCSR0B
    andi r20, ~(1<<UDRIE0)
    sts  UCSR0B, r20
    rjmp usart_udre_exit

usart_udre_send:
    ; Z = &tx_buffer[tail]
    ldi  ZL, low(tx_buffer)
    ldi  ZH, high(tx_buffer)
    add  ZL, r18
    adc  ZH, r1          ; requiere r1 = 0

    ; enviar byte
    ld   r16, Z
    sts  UDR0, r16

    ; tail = (tail + 1) & TX_BUF_MASK
    inc  r18
    andi r18, TX_BUF_MASK   ; con 256 es 0xFF: no cambia, pero deja claro el patrón
    sts  tx_tail, r18

usart_udre_exit:
    pop  ZL
    pop  ZH
    pop  r20
    pop  r18
    pop  r17

    pop  r16
    out  SREG, r16
    pop  r16
    reti



; ----------------------------------------------------------
; PCINT (grupo 2: PORTD). Flanco descendente con pull-ups.
; - PD7 presionado:  ESTADO = S_CINTA ; EVENTO = 0
; - PD2 presionado:  TIPO_Carga = 1->2->3->1 y LEDs en PC2/PC3/PC4
; ----------------------------------------------------------
Interrupcion_PCINT:
    push r16
    in   r16, SREG
    push r16

    in   r16, PIND           ; leer pines (no PORTD)

    ; ¿PD7=0? -> iniciar
    sbrs r16, PD7            ; salta si PD7==1; si está en 0 cae a _pd7
    rjmp _pd7

    ; ¿PD2=0? -> ciclar carga
    sbrs r16, PD2
    rjmp _pd2

    rjmp _done               ; ninguno en 0 -> nada

_pd7:
    ldi  ESTADO, S_CINTA
    clr  EVENTO
    rjmp _done

_pd2:
    ; 1 -> 2 -> 3 -> 1
    inc  TIPO_Carga
    cpi  TIPO_Carga, 4
    brlo _set_leds
    ldi  TIPO_Carga, 1

_set_leds:
    ; PC2,PC3,PC4 como indicador
    cpi  TIPO_Carga, 1
    breq _liv
    cpi  TIPO_Carga, 2
    breq _med
    ; else 3:
    sbi  PORTC, PC4
    cbi  PORTC, PC2
    cbi  PORTC, PC3
    rjmp _done
_liv:
    sbi  PORTC, PC2
    cbi  PORTC, PC3
    cbi  PORTC, PC4
    rjmp _done
_med:
    sbi  PORTC, PC3
    cbi  PORTC, PC2
    cbi  PORTC, PC4

_done:
    pop  r16
    out  SREG, r16
    pop  r16
    reti








.cseg 
.org 0x400 
	MSG_ERROR: 
		.db "Error: comando no encontrado ", 0x0A, 0x0A, 0
	
	MSG_MENU:
		.db "Estado actual: Standby", 0x0A, 0x0A
		.db "Elija una opcion:", 0x0A
		.db "[1] -> Carga ligera            ", 0x0A
		.db "[2] -> Carga mediana           ", 0x0A
		.db "[3] -> Carga pesada            ", 0x0A
		.db "[A] -> Iniciar proceso ", 0x0A, 0x0A, 0
			
	MSG_STATE_1: .db "Estado actual: Alimentación", 0x0A, 0x0A, 0  
	MSG_STATE_2: .db "Estado actual: Espera", 0x0A, 0x0A, 0
	MSG_STATE_3: .db "Estado actual: Punzonado ", 0x0A, 0x0A, 0
	MSG_STATE_4: .db "Estado actual: Espera 2", 0x0A, 0x0A, 0
	MSG_STATE_5: .db "Estado actual: Extracción", 0x0A, 0x0A, 0

	MSG_LOAD_0:	 .db "Carga configurada: Ligera ", 0x0A, 0
	MSG_LOAD_1:	 .db "Carga configurada: Mediana", 0x0A, 0
	MSG_LOAD_2:	 .db "Carga configurada: Pesada ", 0x0A, 0

