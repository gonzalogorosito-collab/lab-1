;
; AssemblerApplication31.asm
;
; Created: 9/20/2025 3:34:02 PM
; Author : isacm
;


 .include "m328pdef.inc"
	.cseg

	.equ TX_BUF_SIZE = 256				; power of two
	.equ TX_BUF_MASK = TX_BUF_SIZE - 1		; 0x0F for size 1
	.equ _F_CPU = 16000000
	.equ _BAUD = 9600
	.equ _BPS = (_F_CPU/16/_BAUD) - 1

	

    .org 0x0000
	    rjmp INICIO

	.org  0x001A
		rjmp CAMBIAR_ESTADO

	.org 0x0024 
		rjmp USART_RX_ISR	; Recieved USART data


	.equ CARGA_LIVIANA = 5
	.equ CARGA_MEDIA = 6
	.equ CARGA_PESADA = 7


	.equ S_ESPERA        = 0  ; 1. En espera – Sistema listo, esperando inicio
	.equ S_CINTA		 = 1   ; 2. Cinta – La cinta transporta la pieza
	.equ S_POSICIONADO   = 2
	.equ S_PUNZONADO     = 3   ; 3. Punzonado – Activación del punzón
	.equ S_CINTA_INVERSA = 4 ; 3. Punzonado – Subirlo cuando termine el timer
	.equ S_ESPERA2        = 5  ; 1. En espera – Sistema listo, esperando inicio
	;DEFINIR UNA SECCION PARA LAS POSIBLES ENTRADAS

	
	.equ MOVER_CINTA = (0<<PD6) | (0<<PD5) | (1<<PD3)
	.equ MOVER_PUNZONADORA = (1<<PD6) | (0<<PD5) | (0<<PD3)
	.equ APAGAR_PUNZONADORA = (0<<PD6) | (0<<PD5) | (0<<PD3)
	.equ MOVER_CINTA_INVERSA = (0<<PD6) | (1<<PD5) | (0<<PD3)

	.def TIPO_Carga= r19
	.def ESTADO= r20
	.def EVENTO= r21

	.org 0x200
		rjmp INICIO

	
	.equ A = 1
	.equ B = 2
	.equ C = 3
	.equ D = 4
	.equ E = 5


	.equ T0_PRELOADL = low(65000)
	.equ T0_PRELOADH = High(65000)
; HASTA AQUI CONFIGURAMOS LOS DATOS A UTILIZAR PARA REALIZAR LAS INTERRUPCIONES


INICIO:
`	ldi r16, high(RAMEND) ; Inicializamos en STACK
	out SPH, r16
	ldi r16, low(RAMEND)
	out SPL, r16 
	
	; Timer1 en modo normal
    LDI r16, 0x00
    STS TCCR1A, r16

    ; Prescaler = clk/1 (puedes usar clk/1024 para hacerlo más lento)
    LDI r16, 0x05
    STS TCCR1B, r16

	; Habilitar interrupción por desbordamiento de Timer1
    LDI r16, (1<<TOIE1)
    STS TIMSK1, r16


	ldi r16, low(_BPS)
	ldi r17, high(_BPS)
	; Set baud rate
	sts UBRR0H, r17
	sts UBRR0L, r16
	; Enable receiver and transmitter, and interruptions
	ldi r16, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
	sts UCSR0B,r16
	; Set frame format: 8data, 2stop bit
	ldi r16, (0<<USBS0)|(3<<UCSZ00)
	sts UCSR0C,r16


	sei

	
	; --- PORTD: PD6, PD5, PD4 como salidas ---
	ldi  r16, (1<<PD6)|(1<<PD5)|(1<<PD3)
	out  DDRD, r16
	
	ldi EVENTO, 1
	
	ldi ESTADO, S_ESPERA
	
	

    rjmp main


; La inicialización donde configuramos, los pines que se van a comportar como salida y entrada en el cidgo, y el timer





main:     
	;Switch para saber que hacer
	
	rcall retardo ; POR AHORA NO ES NCEARIO

	cpi  ESTADO, S_ESPERA
    breq ST_ESPERA


    cpi  ESTADO, S_CINTA
    breq ST_CINTA

	cpi  ESTADO, S_POSICIONADO 
    breq ST_POSICIONADO

	cpi  ESTADO, S_PUNZONADO 
    breq ST_PUNZONADORA

	cpi ESTADO, S_CINTA_INVERSA 
	breq ST_CINTA_INVERSA 

	cpi  ESTADO, S_ESPERA2
    breq ST_ESPERAA2

    rjmp main

; En el main se evalúa el evento, y según que evento este activa las salidas


ST_ESPERA: 
	;sbi PORTD, PD6
    ldi r16, APAGAR_PUNZONADORA 
	out PORTD, r16
    rjmp main

ST_CINTA:
	ldi r16, MOVER_CINTA
	out PORTD, r16
    rjmp main


ST_PUNZONADORA:
	ldi r16, MOVER_PUNZONADORA
	out PORTD, r16
    rjmp main

ST_CINTA_INVERSA:
	ldi r16, MOVER_CINTA_INVERSA
	out PORTD, r16
	rjmp main

ST_POSICIONADO:
	ldi r16, APAGAR_PUNZONADORA 
	out PORTD, r16
    rjmp main

ST_ESPERAA2: 
    ldi r16, APAGAR_PUNZONADORA 
	out PORTD, r16
    rjmp main
; Una primera prueba solo con esperar y mover la cinta

CAMBIAR_ESTADO:
	push r17
    in r17, SREG 
	push r17
	
	inc EVENTO
	
    cpi  ESTADO, S_ESPERA
    breq ST_ESPERA1

	cpi  ESTADO, S_CINTA
    breq ST_CINTA1

	cpi ESTADO, S_POSICIONADO
	breq ST_POSICIONADO1

	cpi  ESTADO, S_PUNZONADO
    breq ST_PUNZONADORA1

	cpi  ESTADO, S_CINTA_INVERSA
    breq ST_CINTA_INVERSA1

    cpi  ESTADO, S_ESPERA2
    breq ST_ESPERA2_1

    rjmp volv                   ; default si no coincide

; -------------------- ESTADO: ESPERA (0) --------------------
ST_ESPERA1:
    cpi  EVENTO, A        ; 1
    brne volv
    ldi  ESTADO, S_CINTA
    
    rjmp volv

; -------------------- ESTADO: CINTA (1) --------------------
ST_CINTA1:
    cpi  EVENTO, B        ; 2
    brne volv
    ldi  ESTADO, S_POSICIONADO
    
    rjmp volv

; -------------------- ESTADO: POSICIONADO (2) ----------------
ST_POSICIONADO1:
	cpi EVENTO, C
	brne volv 
	ldi ESTADO, S_PUNZONADO

	rjmp volv
; -------------------- ESTADO: PUNZONADO (3) ----------------
ST_PUNZONADORA1:
    cpi  EVENTO, D        ; 4
    brne volv
    ldi  ESTADO, S_CINTA_INVERSA
    
    rjmp volv

; -------------------- ESTADO: CINTA_INVERSA (4) ------------
ST_CINTA_INVERSA1:
    cpi  EVENTO, E        ; 5
    brne volv
    ldi  ESTADO, S_ESPERA2      ; o S_ESPERA si querés cerrar el ciclo aquí
    
    rjmp volv

; -------------------- ESTADO: ESPERA2 (5) ------------------
ST_ESPERA2_1:
    ; Si querés que el "último" salte al inicio:
    cpi  EVENTO, A        ; reusamos A para cerrar el ciclo
    brne volv
    ldi  ESTADO, S_ESPERA
    
    rjmp volv
	 
esperar_nuevo:
	ldi ESTADO, S_ESPERA2
	rjmp volv

volv:
	pop r17
	out SREG, r17
	pop r17
    reti


retardo:
    ; Guardar TIMSK1 y deshabilitar overflow de T1
    push r17
    lds  r17, TIMSK1
    push r17
    andi r17, ~(1<<TOIE1)
    sts  TIMSK1, r17

    ; --- Demora por overflow ---
    ldi  r16, (1<<TOV1)       ; limpia bandera previa
    sts  TIFR1, r16

    ; precarga para ~1.000 s con /1024 (F_CPU=16MHz)
    ldi  r16, high(0xC2F7)
    sts  TCNT1H, r16
    ldi  r16, low(0xC2F7)
    sts  TCNT1L, r16

espera_t1:
    lds  r16, TIFR1
    sbrs r16, TOV1            ; ¿overflow?
    rjmp espera_t1
    ldi  r16, (1<<TOV1)       ; limpiar TOV1
    sts  TIFR1, r16

    ; Restaurar TIMSK1
    pop  r17
    sts  TIMSK1, r17
    pop  r17
    ret

; === ISR de recepción USART: recibe '0'..'4' y los mapea a estados 0..4 ===
USART_RX_ISR:
    push r16
    in   r16, SREG
    push r16

    lds  r16, UDR0              ; leer dato recibido limpia RXC

    ; Si llega ASCII '0'..'4', convertir a 0..4 y cargar ESTADO
    cpi  r16, '0'
    brlo usart_end              ; < '0' ? ignorar
    cpi  r16, '5'+1
    brsh usart_end              ; > '5' ? ignorar
    subi r16, '0'               
    mov  ESTADO, r16
    clr  EVENTO                 ; opcional: reiniciar evento al cambiar estado por comando

usart_end:
    pop  r16
    out  SREG, r16
    pop  r16
    reti
