.include "m328pdef.inc"












	; Para USART
	.equ TX_BUF_SIZE = 256				; power of two
	.equ TX_BUF_MASK = TX_BUF_SIZE - 1		; 0x0F for size 1
	.equ _F_CPU = 16000000
	.equ _BAUD = 9600
	.equ _BPS = (_F_CPU/16/_BAUD) - 1


	; Espacio para las vairables guardadas en la RAM
	.dseg ; data segment
		tx_buffer: .byte TX_BUF_SIZE          ; circular buffer storage
		tx_head:   .byte 1                    ; enqueue index
		tx_tail:   .byte 1                    ; dequeue index
		Comenzar: .byte 1

.cseg
    .org 0x0000
		rjmp INICIO

    .org 0x0012
		rjmp overflow

	.org 0x001A
		rjmp overflow2

	.org 0x0024 
		rjmp USART_RX_ISR	; Recieved USART data

	.org 0x0026 
		rjmp USART_UDRE_ISR ; USART Data register clear


	.org 0x0100
		rjmp INICIO





INICIO:
    LDI r16, HIGH(RAMEND)
    OUT SPH, r16
    LDI r16, LOW(RAMEND)
    OUT SPL, r16

    LDI r16, 0x00
    STS TCCR2A, r16
    LDI r16, 0x01
    STS TCCR2B, r16
    LDI r16, 0x01
    STS TIMSK2, r16

	LDI r16, 0x00
    STS TCCR1A, r16
    LDI r16, 0x03
    STS TCCR1B, r16
    LDI r16, 0x01
    STS TIMSK1, r16

	lds  r16, PCICR
    ori  r16, (1<<PCIE2)|(1<<PCIE1)
    sts  PCICR, r16

	; ---------- Configuramos USART ---------- 

	ldi r16, low(_BPS)
	ldi r17, high(_BPS)
	; Set baud rate
	sts UBRR0H, r17
	sts UBRR0L, r16
	; Configurar la recepcion, transmicion e interrupcion de USART
	ldi r16, (1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
	sts UCSR0B,r16
	; COnfigurar los datos de transmicion y de parada; 8data, 2stop bit
	ldi r16, (1<<USBS0)|(3<<UCSZ00)
	sts UCSR0C,r16


 
    sei

    LDI r16, 0xFF
    OUT DDRD, r16

    LDI r16, 0xFF
    OUT DDRB, r16

    ldi r16, 0xFF
    out DDRC, r16

	ldi r16, 0x00
	OUT PORTB, r16

	ldi r16, 0x00
	OUT PORTC, r16
	ldi r22, 0
	ldi r19, 0
	ldi r18, 0
    JMP PRINCIPAL

	clr  r26        ; X.low  = 0   (COL_BASE)
	clr  r27        ; X.high = 0



PRINCIPAL:
	
    RJMP PRINCIPAL



overflow:
	cli
		; Z = H<<1
	ldi  r30, low(H<<1)
	ldi  r31, high(H<<1)

	; Z += X  (r27:r26)
	add  r30, r26
	adc  r31, r27

	; Z += r22  (columna multiplex 0..7)
	add  r30, r22
	adc  r31, r1   ; r1=0 por convención

	; leer columna actual
	lpm  r23, Z
    ; --- avanzás el puntero/contador como ya tenías ---
    inc  r22
    cpi  r22, 8
    brlo f
      ldi  r30, low(H<<1)
      ldi  r31, high(H<<1)
      ldi  r22, 0
f:

    ; === Leer patrón de programa ===
    lpm  r23, Z+               ; r23 = [bits7..0] del patrón

    ; ======= PORTB: poner bits7..6 -> PB5..PB4 =======
    mov  r20, r23
    andi r20, 0b11000000       ; aislar bits 7..6
    lsr  r20                   ; desplazarlos a PB5..PB4
    lsr  r20                   ; (>>2)

    in   r16, PORTB            ; R-M-W: preservar otros bits
    andi r16, 0b11001111       ; limpiar PB5|PB4 (bit5 y bit4)
    or   r16, r20              ; mezclar nuevos bits en PB5..PB4
    out  PORTB, r16

    ; ======= PORTC: poner bits5..0 -> PC5..PC0 =======
    mov  r21, r23
    andi r21, 0b00111111       ; aislar bits 5..0 (ya alineados a PC5..PC0)

    in   r17, PORTC            ; R-M-W
    andi r17, 0b11000000       ; limpiar PC5..PC0 (dejar PC7..PC6 intactos)
    or   r17, r21
    out  PORTC, r17

	rcall prender
	
 
	sei
	
    reti


prender:
    push r30
    push r31
    push r19
    push r20
    push r21
    push r16
    push r17

    ; Z -> ROW_MASK + r22 (tabla en PROGMEM)
    ldi  r30, low(ROW_MASK<<1)
    ldi  r31, high(ROW_MASK<<1)
    add  r30, r22
    adc  r31, r1   

    lpm  r19, Z                ; r19 = máscara: [PD7..PD4 | PC3..PC0]

    ; ------ PORTC: aplicar nibble bajo (PC0..PC3) ------
    mov  r20, r19
    andi r20, 0x0F             ; aislar PC3..PC0
    in   r16, PORTB           ; R-M-W: preservar PC7..PC4
    andi r16, 0xF0             ; limpiar solo PC3..PC0
    or   r16, r20              ; setear el bit seleccionado
    out  PORTB, r16

    ; ------ PORTD: aplicar nibble alto (PD7..PD4) ------
    mov  r21, r19
    andi r21, 0xF0             ; aislar PD7..PD4
    in   r17, PORTD            ; R-M-W: preservar PD3..PD0
    andi r17, 0x0F             ; limpiar solo PD7..PD4
    or   r17, r21              ; setear el bit seleccionado
    out  PORTD, r17

    pop  r17
    pop  r16
    pop  r21
    pop  r20
    pop  r19
    pop  r31
    pop  r30

	ret
	


overflow2:
    adiw r26, 1           
    andi r26, 0x3F         
    clr  r27              
    reti



	USART_WRITE_BYTE:
    push r17
    push r18
    push r19
    push ZH
    push ZL

    ; head/tail
    lds  r17, tx_head
    lds  r18, tx_tail

    ; next = (head + 1) & MASK   (keep it in r19!)
    mov  r19, r17
    inc  r19
    andi r19, TX_BUF_MASK

wait_space:
    ; full? next == tail
    cp   r19, r18
    brne have_space
    ; maybe ISR advanced tail while we were here ? reload tail and re-check
    lds  r18, tx_tail
    cp   r19, r18
    breq wait_space

have_space:
    ; Z = &tx_buffer[head]
    ldi  ZL, low(tx_buffer)
    ldi  ZH, high(tx_buffer)
    add  ZL, r17
    adc  ZH, r1            ; r1 must be 0

    st   Z, r16            ; write byte

    ; head = next   (use r19, NOT ZL)
    sts  tx_head, r19

    ; enable UDRE interrupt so ISR starts/continues draining
    cli
    lds  r18, UCSR0B
    ori  r18, (1<<UDRIE0)
    sts  UCSR0B, r18
    sei

    pop  ZL
    pop  ZH
    pop  r19
    pop  r18
    pop  r17
    ret

; === ISR de recepción USART: '1','2','3' -> TIPO_Carga ===
USART_RX_ISR:
    push r16
    in   r16, SREG
    push r16

    lds  r16, UDR0                  ; leer dato recibido limpia RXC



usart_end:
    pop  r16
    out  SREG, r16
    pop  r16
    reti

delay:
	push r16
	in r16, sreg
	push r16

    ldi  r16, high(0xC2F7)
    sts  TCNT1H, r16
    ldi  r16, low(0xC2F7)
    sts  TCNT1L, r16

	pop r16
	out sreg, r16
	pop r16
    ret


; Preload Z with the message
SEND_MESSAGE:
	push r16

	SEND_MESSAGE_LOOP:
	lpm r16, Z+
	cpi r16, 0

	breq SEND_MESSAGE_END
	rcall USART_WRITE_BYTE
	rjmp SEND_MESSAGE_LOOP

	SEND_MESSAGE_END:
	pop r16
	ret


USART_UDRE_ISR:
    push r16
    in   r16, SREG
    push r16

    push r17
    push r18
    push r20
    push ZH
    push ZL

    ; r17 = head, r18 = tail
    lds  r17, tx_head
    lds  r18, tx_tail

    ; buffer vacío? head == tail
    cp   r17, r18
    brne usart_udre_send

    ; vacío: deshabilitar UDRIE0
    lds  r20, UCSR0B
    andi r20, ~(1<<UDRIE0)
    sts  UCSR0B, r20
    rjmp usart_udre_exit

usart_udre_send:
    ; Z = &tx_buffer[tail]
    ldi  ZL, low(tx_buffer)
    ldi  ZH, high(tx_buffer)
    add  ZL, r18
    adc  ZH, r1          ; requiere r1 = 0

    ; enviar byte
    ld   r16, Z
    sts  UDR0, r16

    ; tail = (tail + 1) & TX_BUF_MASK
    inc  r18
    andi r18, TX_BUF_MASK   ; con 256 es 0xFF: no cambia, pero deja claro el patrón
    sts  tx_tail, r18

usart_udre_exit:
    pop  ZL
    pop  ZH
    pop  r20
    pop  r18
    pop  r17

    pop  r16
    out  SREG, r16
    pop  r16
    reti



	.org 0x320 ROW_MASK:
		.db 0b00001000, 0b00000100, 0b00000010, 0b00000001, 0b10000000, 0b01000000, 0b00100000, 0b00010000
	
			; === Column tables, active-low (negado), left→right ===
		.org 0x0500

				; ===== 6×8, columnas, active-low (0 = LED ON), bit7 = fila superior =====
		; Usa BLANK entre letras para más espacio visual.

		H:
			.db  0b11111111, 0b00000000, 0b11101111, 0b11101111,  0b00000000, 0b11111111
		; pilares completos a los lados y barra media (fila 3) en el centro

		O:
			.db 0b11111111, 0b00000000, 0b01111110, 0b01111110, 0b00000000, 0b11111111
		; caja hueca: laterales llenos + arriba/abajo

		L:
			.db 0b00000000, 0b11111110, 0b11111110, 0b11111110, 0b11111110, 0b11111110
		; pilar izquierdo + base

		A:
			.db 0b00000000, 0b01101111, 0b01101111, 0b01101111, 0b01101111, 0b00000000
		; barra arriba + barra media (fila 3) + laterales

		J:
			.db 0b01111110, 0b01111110, 0b01111110, 0b01111110, 0b01111110, 0b00000000
		; barra arriba + pilar derecho con gancho simple abajo (minimalista)

		E:
			.db 0b00000000, 0b01101110, 0b01101110, 0b01101110, 0b01101110, 0b11111111
		; pilar izquierdo + arriba/medio/abajo; última columna en blanco para estilizar

		S:
			.db 0b01111110, 0b01111111, 0b01101111, 0b11110111, 0b11111110, 0b01111110
		; arriba + medio + abajo con cambio de laterales (forma “S” compacta)

		U:
			.db 0b00000000, 0b11111110, 0b11111110, 0b11111110, 0b11111110, 0b00000000
		; laterales + base







